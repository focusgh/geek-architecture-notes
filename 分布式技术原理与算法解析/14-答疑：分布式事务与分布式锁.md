[TOC]

## 14 | 答疑篇：分布式事务与分布式锁相关问题

### 分布式事务的相关问题

-   问题1：**两阶段提交协议（2PC）和三阶段提交协议（3PC）的区别，到底是什么**？
    -   2PC 中，如果所有参与者都返回结果后，会进入第二阶段，也就是提交执行阶段，根据第一阶段的投票结果，进行提交或取消。
    -   3PC 中，进入真正的提交阶段前，还会有一个预提交阶段，这个预提交阶段不会真正的提交，而是会将相关信息记录到事务日志中，当所有参与者都返回 Yes 消息后，才会真正进入提交阶段。
-   追问1：3PC 在预提交阶段，才开始执行事务操作，那协调者发送 CanCommit 给参与者的时候，参与者根据什么返回 Yes 或 No 消息呢？
    -   参与者根据自身情况，预估自己是否可以执行事务。
-   追问2：3PC 出现的目的，解决了 2PC 的同步阻塞和数据不一致的问题。那么，我们可以在 2PC 中直接去解这些问题吗？3PC 多个预提交和超时机制，就真的解决问题了吗？
    -   3PC 是针对 2PC 存在的问题做的进一步改进，虽然没能完全解决这些问题，但也起到一定的效果。
-   追问3：3PC 也只有一个协调者，为什么就不会有单点故障问题了？
    -   3PC 因为在协调者和参与者中引入了超时机制，可以减弱单点故障对整个系统造成的影响。

### 分布式锁的相关问题

-   问题1： 分布式互斥和分布式锁的关系是什么？
    -   分布式锁的目的是，保证多个进程访问临界资源时，同一时刻只有一个进程可以访问，以保证数据的正确性。因此，我们可以说，分布式锁是实现分布式互斥的一种手段或方法。
-   问题2： Zookeeper 分布式锁，可能存在多个节点对应的客户端在同一时间完成事务的情况吗？
    -   存在多个节点对应的客户端与 Zookeeper 进行交互。同时，由于分布式节点之间并未进行通信协商，且它们都是独立自主的，启动时间、与 Zookeeper 交互的时间、事务完成时间都是独立的，因此存在多个节点对应的客户端在同一时间完成事务的情况。

-   问题3： Redis 为什么需要通过队列来维持进程访问共享资源的先后顺序？
    -   如果没有队列维护多进程请求，那我们可以想到的解决方式，就是我刚刚和你分析过的，通过多进程反复尝试获取锁。这种方式有三个问题：
        1.  反复尝试会增加通信成本和性能开销。
        2.  到底过多久再重新尝试。
        3.  如果每次都是众多进程进行竞争的话，有可能会导致有些进程永远获取不到锁。
    -   基于队列来维持进程访问共享资源先后顺序的方法中，当一个进程释放锁后，队列第一个进程可以访问共享资源。也就是说，这样一来就解决了上面提到的三个问题。

