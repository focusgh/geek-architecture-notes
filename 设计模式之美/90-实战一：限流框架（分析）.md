[toc]

## 90 | 项目实战一：设计实现一个支持各种算法的限流框架（分析）

1.  项目实战部分，我们找三个有点难度的项目：**限流框架、幂等框架、灰度发布组件**。
2.  重点学习它们背后的**开发套路**。
3.  今天，我们先讲其中的**分析**环节，介绍项目背景，分析项目需求。

### 项目背景

1.  初期
    -   项目只做简单的前后端分离。
    -   后端所有代码在一个 GitHub 仓库中。
    -   整个后端作为一个应用来部署，没有划分微服务。
2.  改进
    -   把公共的功能、代码抽离出来，形成一个独立的项目，部署成一个**公共服务平台**。
    -   为**减少部署、维护多个微服务的成本**。我们把所有公共功能，放到一个项目中开发，放到一个应用中部署。不过，需要将代码的**模块化**做好。方便后期拆分出来，设计成独立的服务来开发和部署。
    -   指派一个团队，**集中维护公共服务平台代码**。降低维护成本，便于重构、改善代码质量。

### 需求背景

1.  因为调用方问题，导致某个**接口请求突增，过度争用服务资源**。
2.  为解决这个问题，你有什么好建议？
    -   **开发接口限流功能**，限制每个调用方接口请求频率。
    -   目标：把它开发成一个通用框架（**抽象意识、框架意识**）。

### 需求分析

1.  我们再对需求进行更加详细的**分析和整理**。

2.  对于限流框架，它的**应用场景**：

    -   首先，**设置限流规则**。

        -   ```yaml
            
            configs:
            - appId: app-1
              limits:
              - api: /v1/user
                limit: 100
              - api: /v1/order
                limit: 50
            - appId: app-2
              limits:
              - api: /v1/user
                limit: 50
              - api: /v1/order
                limit: 50
            ```

    -   **提供接口**，验证请求是否被限流。

        -   ```java
            
            String appId = "app-1"; // 调用方APP-ID
            String url = "http://www.eudemon.com/v1/user/12345";// 请求url
            RateLimiter ratelimiter = new RateLimiter();
            boolean passed = ratelimiter.limit(appId, url);
            if (passed) {
              // 放行接口请求，继续后续的处理。
            } else {
              // 接口请求被限流。
            }
            ```

3.  **非功能性需求**

    -   **易用性**，希望提供各种不同的限流算法。
    -   **扩展性、灵活性**，希望能够灵活地扩展各种限流算法、支持不同格式、不同数据源。
    -   **性能**，尽可能低延迟、减少对接口请求本身响应时间的影响。
    -   **容错性**，不能因为限流框架的异常，反过来影响到服务本身的可用性。

### 重点回顾

1.  今天，我们主要对限流框架做了大的**项目背景、需求背景**的介绍，以及做了更加具体的**需求分析**，明确了要做什么。
2.  考虑了**非功能性需求**：易用、灵活、可扩展、低延迟、高容错。
3.  考虑了限流框架的应用场景。

