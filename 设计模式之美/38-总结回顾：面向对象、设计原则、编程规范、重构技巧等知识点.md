[toc]

## 38 | 总结回顾：面向对象、设计原则、编程规范、重构技巧等知识点

-   ![img](imgs/f3262ef8152517d3b11bfc3f2d2b12d3-20200211180943823.png)



### 一、代码质量评判标准

#### 如何评价代码质量高低？

-   代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，如可读性、可维护性、灵活、优雅。
-   代码质量高低是一个综合各种因素得到的结论，我们并不能通过单一维度去评价一段代码的好坏。

#### 最常用的评价标准有哪几个？

-   最常用的几个评判质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。
-   其中，**可维护性、可读性、可扩展性**又是提到最多的、最重要的几个评判

#### 如何才能写出高质量的代码？

-   要写出高质量的代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编程规范、重构技巧等。

#### 思维导图

-   ![img](imgs/34c51d1eb44ffc099d448ad10bcda82b.jpg)

### 二、面向对象

#### 1. 概述

-   面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

#### 2. 四大特性

-   **封装**
    -   也叫信息隐藏或数据访问保护。
    -   一方面是保护数据不被随意修改，提高代码的可维护性。
    -   另一方面是仅暴露有限的必要接口，提高类的易用性。
-   **抽象**
    -   讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。
    -   可以通过接口类或抽象类来实现。
    -   一方面是修改实现不需要改变定义。
    -   另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
-   **继承**
    -   表示类间的 is-a 关系，分为两种模式：单继承和多继承。
    -   主要用来解决代码复用问题。
-   **多态**
    -   指子类可以替换父类，在实际代码运行的过程中，调用子类的方法实现。
    -   多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

#### 3. 面向对象 VS 面向过程

-   面向对象相比面向过程编程的优势主要有三个：
    -   面向对象编程能更好的应对大规模复杂程序的开发。
    -   具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
    -   面向对象编程语言更加人性化、更加高级、更加智能。

#### 4. 面向对象分析、设计与编程

-   简单的说
    -   **面向对象分析就是要搞清楚做什么。**
    -   **面向对象设计就是要搞清楚怎么做。**
    -   **面向对象编程就是将分析和设计的结果翻译成代码的过程。**
-   **需求分析**的过程实际上是一个不断迭代优化的过程。
-   **面向对象设计和实现**要做的事情就是的把合适的代码放到合适的类中。
-   面向对象分析产出的是需求描述。面向对象设计产出的是类。我们将需求描述转化为具体类的设计，这个环节的工作可以划分为下面四个部分：
    1.  划分职责进而识别出有哪些类
    2.  定义类及其属性和方法
    3.  定义类与类之间的交互关系
        -   泛化、实现、组合、依赖
    4.  将类组装起来并提供执行入口

#### 5. 接口 VS 抽象类

-   **抽象类**不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。子类继承抽象类，必须实现抽象类中所有抽象方法。
-   **接口**不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口时，必须实现接口中声明的所有方法。
-   **抽象类**是对成员变量和方法的抽象，是一种 is-a 关系，是为解决代码复用问题。
-   **接口**仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。
-   **什么时候用抽象类？什么时候用接口？**
    -   如果要表示一种 is-a 的关系，并是为了解决代码复用的问题，我们就用抽象类。
    -   如果要表示一种 has-a 的关系，并且是为了解决抽象而非代码复用的问题，那我们就用接口。

#### 6. 基于接口而非实现编程

-   这条原则，**可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。**
-   抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

#### 7. 多用组合少用继承

-   **为什么不推荐使用继承？**
    -   继承层次过深、过复杂，也会影响到代码的可维护性。
-   **组合相比继承有哪些优势？**
    -   组合能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
-   **如何判断该用组合还是继承？**
    -   如果类间的继承结构稳定，层次较浅，关系不复杂，我们就大胆使用继承。
    -   反之，就尽量使用组合。

#### 8. 贫血模型 VS 充血模型

#### 思维导图

-   ![img](imgs/f4ce06502a9782d200e8e10a90bf2ce7.jpg)

### 三、设计原则（SOLID 原则）

#### 1. SRP 单一职责原则

-   **一个类只负责完成一个职责或功能。**
-   单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类的职责单一，类依赖和被依赖的其他类也会变少，减少代码的耦合性，以此来实现代码的高内聚、松耦合。
-   一些侧面的判断指标更具有指导意义和可执行性，如下一些情况就有可能说明这类的设计不满足单一职责原则：
    1.  类中代码行数、函数或属性过多。
    2.  类依赖的其他类过多或依赖类的其他类过多。
    3.  私有方法过多。
    4.  比较难给类走一个合适的名字。
    5.  类中大量的方法都集中操作类中的某几个属性。

#### 2. OCP 开闭原则

-   如何**理解**“对扩展开放、修改关闭”？
    -   添加一个新的功能，应该是通过在已有代码的基础上扩展代码，而非修改已有的代码来完成。
-   如何**做到**“对扩展开发、修改关闭”？
    -   我们要时刻具备扩展、抽象、封装意识。
    -   在写代码时，多花点时间思考一下，末来可能有哪些需求变更，如何设计代码结构，事先留好扩展点。
    -   最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，及大部分的设计模式（如，装饰、策略、模板、职责链、状态）。

#### 3. LSP 里式替换原则

-   子类对象能够替换程序中父类对象出现的任何地方，并且**保证原来程序的逻辑行为不变及正确性不被破坏**。
-   里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解**“design by contract，按照协议来设计”**
-   与多态的区别
    -   多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路，
    -   里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

#### 4. ISP 接口隔离原则

-   **客户端不应该强迫依赖它不需要的接口。**
-   接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也不同。
    -   接口隔离原则提供了一种判断接口的职责是否单一的标准。

#### 5. DIP 依赖倒置原则

-   **控制反转**
    -   一般用来指导框架层面的设计。
    -   **流程的控制权从程序员“反转”给了框架。**
-   **依赖注入**
    -   与控制反转相反，它是一种具体的编码技巧。
    -   我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好，通过构造函数、函数参数等方式传递（或“注入”）给类来使用。
-   **依赖注入框架**
    -   实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事。
-   **依赖反转原则**
    -   与控制反转有点类似，主要用来指导框架层面设计。
    -   **高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。**

#### 6. KISS、YAGNI 原则

-   KISS 原则：**尽量保持简单**
-   如果写出满足 KISS 原则的代码，我总结了下面几条指导原则：
    -   不使用同事可能不懂的技术来实现代码。
    -   不要重复造轮子，善于使用已经有的工具类库。
    -   不要过度优化。
-   YAGNI 原则：**不要做过度设计**。
-   两者区别：
    -   KISS 原则讲的是“**如何做**”的问题。
    -   YAGNI 原则讲的提“**要不要做**”的问题。

#### 7. DRY 原则

-   **不要写重复代码**
-   专栏中讲到了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。
    -   实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
    -   实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。
    -   代码重复也算是违反 DRY 原则。
-   相比于代码的可复用性，DRY 原则适用性更强些。我们可以不写可复用的代码，但一定不能写重复的代码。

#### 8. LOD 原则

-   **如果理解“高内聚、松耦合”？**
    -   “**高内聚**”是用来指导类本身的设计。
        -   相近的功能放到一个类中，不相近的功能不要放到一个类中。
    -   “**松耦合**”用来指导类与类之间依赖关系的设计。
        -   在代码中，类与类间的依赖关系简单清晰。
        -   即使两个类有依赖关系，一个类的改动也不会或者很少导致依赖类的代码改动。
-   **如何理解“迪米特法则”？**
    -   不该有直接依赖关系的类之间，不要有依赖。
    -   有依赖关系的类之间，尽量只依赖必要的接口。

#### 思维导图

-   ![img](imgs/fbf1ae0ce08d4ea890b80944c2b8309f.jpg)

### 四、规范与重构

#### 1. 重构概述

-   **目的：为什么重构（why）?**
    -   对项目而言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。
    -   对个人而言，非常锻炼一个人的代码能力
-   **对象：重构什么（what）?**
    -   **大重构**
        -   对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等。
        -   这部分主要利用更多的是比较抽象、比较顶层的**设计思想、原则、模式**。
    -   **小重构**
        -   规范命名、注释、修改函数参数过多、消除超大类、提取重复代码等编程细节问题。
        -   这部分主要利用**编程规范**这一理论知识。
-   **时机：什么时候重构（when）?**
    -   建立持续重构的意识，把重构作为开发必不可少的部分融入到开发中。
-   **方法：如何重构（how）**
    -   大重构，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。
    -   小重构，只要愿意且有时间，随时随地可以去做。

#### 2. 单元测试

-   **什么是单元测试？**

    -   单元测试是代码层面的测试用于测试“自己”编写的代码逻辑正确性。

-   **为什么要写单元测试？**

    -   单元测试能有效地发现代码中的 Bug、代码设计上的问题。
    -   写单元测试的过程本身就是代码重构的过程。
    -   单元测试是对集成测试有力的补充，能帮助我们快速熟悉代码，是 TDD 可落地执行的折中方案。

-   **如何编写单元测试？**

    -   写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。

    -   对于单元测试，我们需要建立以下正确的认知：

        >   编写单元测试尽管繁琐，但并不是太耗时。
        >
        >   我们可以稍微放低单元测试的质量要求。
        >
        >   覆盖率真作为衡量单元测试好坏的唯一标准是不合理的。
        >
        >   写单元测试一般不需要了解代码的实现逻辑。
        >
        >   单元测试框架无法测试多半是代码的可测试性不好。

-   **单元测试为何难落地**

    -   一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。
    -   另一方面，国内研发比较偏向“快糙猛”，因为开发进度紧，导致单元测试的执行虎头蛇尾。

#### 3. 代码的可测试性

-   **什么是代码的可测试性？**
    -   针对代码编写单元测试的难易程序。
-   **编写可测试性代码的最有效段**
    -   依赖注入是编写可测试性代码的最有效的手段。
-   **常见的 Anti-Patterns**
    -   典型的、常见的测试不友好的代码有下面 5 种：
        -   代码中包含未决行为逻辑。
        -   滥用可变全局变量。
        -   滥用静态方法。
        -   使用复杂的继承关系。
        -   高度耦合的代码。

#### 4. 大型重构：**解耦**

-   **“解耦”为何如此重要？**
    -   解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。
    -   如果代码高内聚、松耦合，也就意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。
-   **代码是否需要“解耦”？**
    -   间接的衡量标准有很多，如：
        -   改动一个模块或类的代码受到影响的模块或类是否有很多。
        -   改动一个模块或类的代码依赖的模块或者类是否需要改动。
        -   代码的可测试性是否好
    -   直接的衡量标准：
        -   把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。
-   **如何给代码“解耦”？**
    -   封装与抽象、中间层、模块化
    -   以及一些其他的设计思想与原则，如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。
    -   还有一些设计模式，如：观察者模式。

#### 5. 小型重构：**编码规范**

-   命名与注释

    -   命名的关键是能准确达意。
    -   我们借助类和信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
    -   命名要可读、可搜索。
    -   接口有两种命名方式，一种是接口中带前缀 "I"，一种是带后缀 “Impl”。对于抽象类命名，我们更倾向于带有前缀 “Abstract”。
    -   注释的目的是让代码更容易看懂，只要符合这个要求，就可以。总结一下，注释主要包含三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明 “如何用”。
    -   注释本身有一定的维护成本，所以并非越多越好。

-   代码风格

    -   只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目代码风格相一致。

-   编程技巧

    -   将复杂的逻辑提炼拆分成函数和类。

    -   通过拆分成多个函数的方式来处理参数过多的情况。

    -   通过将参数封装成对象来处理参数过多的情况。

    -   函数中不要使用参数来做代码执行逻辑的控制。

    -   移过过深的嵌套层次，方法包括：

        -   去掉多余的 if 或 else 语句

        -   使用 continue、break、return 关键字提前退出嵌套
        -   调整执行顺序来减少嵌套
        -   将部分嵌套逻辑抽象成函数

    -   用字面常量取代魔法数。

    -   利用解释性变量来解释复杂表达式。

-   统一编程规范

    -   项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。

#### 思维导图

-   ![img](imgs/fc56f7c2b348d324c93a09dd0dee538a.jpg)

