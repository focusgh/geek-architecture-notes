[toc]

## 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否“单一”？

-   从今天起，我们开始学习一些经典的设计原则：SOLID、KISS、YAGNI、DRY、LOG 等。
-   我们不仅讲解这些原则的定义，还会解决这些原则的设计的初衷，能解决哪些问题，有哪些应用场景等，让你知其然知其所以然。

### 如何理解单一职责原则（SRP）?

-   今天，我们学习 SOLID 原则中的第一个原则：**单一职责原则**。

    >   **一个类或者模块只负责完成一个职责（或功能）。**
    >
    >   
    >
    >   不要设计大而全的类，要设计粒度小、功能单一的类。
    >
    >   换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它的职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

### 如何判断类的职责是否足够单一？

-   不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都不一样的。

-   从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。

-   实际上，在真正的软件开发中：

    >   **我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。**
    >
    >   **这就是所谓的持续重构。**

-   几个判定原则：

    1.  **类中的代码行数、函数或属性过多**，会影响代码的可读性和或维护性，我们就要考虑对类进行拆分。
    2.  **类依赖的其他类过多，或者依赖类的其他类过多**，不符合高内聚、低耦合的设计思想，我们就要考虑对类进行拆分。
    3.  **私有方法过多**。
    4.  **比较难给类起一个合适的名字**，这就说明类的职责定义得可能不够清晰。
    5.  **类中大量的方法都集中操作类中的某几个属性**。

### 类的职责是否设计得越单一越好？

-   答案是“否定”的。
-   如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。
-   实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。

### 重点回顾